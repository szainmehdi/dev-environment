# -----------------------------------------------
# Git Aliases
# -----------------------------------------------
alias grep='grep --color=auto --exclude-dir={.bzr,.cvs,.git,.hg,.svn}'
function gcom() {
    git checkout master 2> /dev/null
    ret=$?
    if [ $ret -ne 0 ]; then
        git checkout main
    fi
}
alias gaa='git add --all'
alias gcod='gco develop'
alias gc='git commit'
alias gdc='gd --cached'
alias gb='git branch'

# -----------------------------------------------
# Numbered File Support
# -----------------------------------------------
# Colors
_c_reset=$'\e[0m'
_c_gray=$'\e[90m'
_c_green=$'\e[32m'
_c_yellow=$'\e[33m'
_c_red=$'\e[31m'
_c_cyan=$'\e[36m'
_c_bold=$'\e[1m'

# Show git status with numbered files (SCM Breeze style)
unalias gs 2>/dev/null
gs() {
    # Check if in a git work tree
    if [[ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != "true" ]]; then
        echo "${_c_red}Not a git repository${_c_reset}"
        return 1
    fi

    # Branch info
    local branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)

    echo "${_c_gray}#${_c_reset}"
    if [[ -n "$upstream" ]]; then
        echo "${_c_gray}# On branch: ${_c_bold}${branch}${_c_reset}${_c_gray}...${upstream}${_c_reset}"
    else
        echo "${_c_gray}# On branch: ${_c_bold}${branch}${_c_reset}"
    fi
    echo "${_c_gray}#${_c_reset}"

    # Collect files into groups (without numbers yet)
    local staged_files=()
    local staged_st=()
    local unstaged_files=()
    local unstaged_st=()
    local untracked_files=()

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local idx="${line:0:1}"
        local wt="${line:1:1}"
        local file="${line:3}"

        if [[ "$idx" == "?" ]]; then
            untracked_files+=("$file")
        else
            [[ "$idx" != " " ]] && staged_files+=("$file") && staged_st+=("$idx")
            [[ "$wt" != " " ]] && unstaged_files+=("$file") && unstaged_st+=("$wt")
        fi
    done < <(git status --porcelain)

    # Number in display order: staged, unstaged, untracked
    local n=1

    # Staged changes
    if [[ ${#staged_files[@]} -gt 0 ]]; then
        echo "${_c_green}➤ Changes to be committed${_c_reset}"
        echo "${_c_gray}#${_c_reset}"
        for i in {1..${#staged_files[@]}}; do
            local file="${staged_files[$i]}"
            local st="${staged_st[$i]}"
            local label="modified"
            [[ "$st" == "A" ]] && label="new file"
            [[ "$st" == "D" ]] && label="deleted"
            [[ "$st" == "R" ]] && label="renamed"
            echo "${_c_gray}#      ${label}: ${_c_reset}[${_c_cyan}${n}${_c_reset}] ${_c_green}${file}${_c_reset}"
            ((n++))
        done
        echo "${_c_gray}#${_c_reset}"
    fi

    # Unstaged changes
    if [[ ${#unstaged_files[@]} -gt 0 ]]; then
        echo "${_c_yellow}➤ Changes not staged for commit${_c_reset}"
        echo "${_c_gray}#${_c_reset}"
        for i in {1..${#unstaged_files[@]}}; do
            local file="${unstaged_files[$i]}"
            local st="${unstaged_st[$i]}"
            local label="modified"
            [[ "$st" == "D" ]] && label="deleted"
            echo "${_c_gray}#      ${label}: ${_c_reset}[${_c_cyan}${n}${_c_reset}] ${_c_yellow}${file}${_c_reset}"
            ((n++))
        done
        echo "${_c_gray}#${_c_reset}"
    fi

    # Untracked files
    if [[ ${#untracked_files[@]} -gt 0 ]]; then
        echo "${_c_red}➤ Untracked files${_c_reset}"
        echo "${_c_gray}#${_c_reset}"
        for file in "${untracked_files[@]}"; do
            echo "${_c_gray}#      untracked: ${_c_reset}[${_c_cyan}${n}${_c_reset}] ${_c_red}${file}${_c_reset}"
            ((n++))
        done
        echo "${_c_gray}#${_c_reset}"
    fi

    # Clean working tree
    if [[ ${#staged_files[@]} -eq 0 && ${#unstaged_files[@]} -eq 0 && ${#untracked_files[@]} -eq 0 ]]; then
        echo "${_c_green}# Nothing to commit, working tree clean${_c_reset}"
    fi
}

# Get the list of changed files in display order (staged, unstaged, untracked)
_git_files() {
    local staged=() unstaged=() untracked=()
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local idx="${line:0:1}"
        local wt="${line:1:1}"
        local file="${line:3}"
        if [[ "$idx" == "?" ]]; then
            untracked+=(":/$file")
        else
            [[ "$idx" != " " ]] && staged+=(":/$file")
            [[ "$wt" != " " ]] && unstaged+=(":/$file")
        fi
    done < <(git status --porcelain)
    printf '%s\n' "${staged[@]}" "${unstaged[@]}" "${untracked[@]}"
}

# Expand number arguments to file paths
# Supports: 1, 1-3, 1 2 3
_expand_git_nums() {
    local files=("${(@f)$(_git_files)}")
    local result=()

    for arg in "$@"; do
        if [[ $arg =~ ^([0-9]+)-([0-9]+)$ ]]; then
            # Range: 1-3
            for i in $(seq ${match[1]} ${match[2]}); do
                [[ -n "${files[$i]}" ]] && result+=("${files[$i]}")
            done
        elif [[ $arg =~ ^[0-9]+$ ]]; then
            # Single number
            [[ -n "${files[$arg]}" ]] && result+=("${files[$arg]}")
        else
            # Pass through non-numeric args (flags, filenames)
            result+=("$arg")
        fi
    done

    echo "${result[@]}"
}

# Git add by number: ga 1 2-4
unalias ga 2>/dev/null
ga() {
    if [[ $# -eq 0 ]]; then
        git add
    else
        local files=$(_expand_git_nums "$@")
        [[ -n "$files" ]] && git add ${=files}
    fi
    gs
}

# Git diff by number: gd 1 2
unalias gd 2>/dev/null
gd() {
    if [[ $# -eq 0 ]]; then
        git diff
    else
        local files=$(_expand_git_nums "$@")
        [[ -n "$files" ]] && git diff ${=files}
    fi
}

# Git checkout (restore) by number: gco 1-3
unalias gco 2>/dev/null
gco() {
    if [[ $# -eq 0 ]]; then
        git checkout
    else
        local files=$(_expand_git_nums "$@")
        [[ -n "$files" ]] && git checkout ${=files}
    fi
}

# Git reset by number: gr 1 2
unalias gr 2>/dev/null
gr() {
    if [[ $# -eq 0 ]]; then
        git reset
    else
        local files=$(_expand_git_nums "$@")
        [[ -n "$files" ]] && git reset ${=files}
    fi
}
## Push the current branch to origin/{your-current-branch} and set tracking for the future.
function gpup () {
    git push -u origin `git symbolic-ref --short HEAD`
}
function pr () {
    base="$1"
    if [ -z "$base" ]; then
        gh pr create --web
    else
        gh pr create --web --base "$base"
    fi
}
function repo() {
    cd "$(git rev-parse --show-toplevel)"
}
